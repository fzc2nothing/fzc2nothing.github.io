---
layout:     post
title:      Nobody can judge me
subtitle:   No time to waste
date:       2020-05-08
author:     Zichao
header-img: img/ghostdoll.jpeg
catalog: true
tags:
    - leetcode
    - paper
---

# 5/8/2020

- [ ]  JavaScript restart (left a little), fininsh this chapter and start next

- [ ]  Web develop, finish one chapter

- [ ]  C++ start

- [ ]  os restart

## LeetCode

### 200. Number of islands
做了好几遍了，三个函数，分别计算岛的数量，用bfs探索邻居，判断其在不在棋盘范围内，坐标类用来指示坐标，两个数组来指代横向纵向位移
```
    class Solution {
    
    class Coordinate {
        int x;        
        int y;
        public Coordinate (int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    
    public int numIslands(char[][] grid) {
        
        if(grid.length == 0 || grid[0].length == 0) {
            return 0;
        } 
        
        int m = grid.length;
        
        int n = grid[0].length;
        
        int count = 0;
        
        for(int i = 0; i<m; i++) {
            for(int j = 0; j<n; j++) {
                if(grid[i][j] == '1') {
                    BFS(grid,i,j);
                    count++;
                }
                
            }
        }
        
        return count;
        
    }
    
    private void BFS(char[][] grid, int x, int y) {

            int[] deltaX = {1,0,0,-1};

            int[] deltaY = {0,1,-1,0};

            Queue<Coordinate> queue = new LinkedList<>();

            Coordinate start = new Coordinate(x,y);

            queue.offer(start);
        
            grid[start.x][start.y] = '0';

            while(!queue.isEmpty()) {
                Coordinate temp = queue.poll();
                
                for(int i= 0; i<4; i++) {
                    Coordinate neighbor = new Coordinate(
                    temp.x+deltaX[i],
                    temp.y+deltaY[i]
                    );
                if(inBound(grid,neighbor.x,neighbor.y)&&(grid[neighbor.x][neighbor.y] == '1')) {
                    queue.offer(neighbor);
                    grid[neighbor.x][neighbor.y] = '0';
                }
            }


        }
    }
    private boolean inBound(char[][] grid, int x, int y) {
        int m = grid.length;
        
        int n = grid[0].length;
        
        return x >= 0 && x < m && y>=0 && y <n;
        }
    }
```